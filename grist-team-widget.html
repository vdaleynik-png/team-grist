<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Team Directory — Grist Widget</title>

  <!-- Grist Plugin API -->
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>

  <!-- Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      /* ===== Grist-like theme ===== */
      --bg:#0f1116;
      --panel:#151922;
      --panel-2:#1b2230;
      --text:#e7ecf2;
      --muted:#8b96a9;

      /* Accents (Grist fallbacks) */
      --accent: var(--grist-primary-fg, #16B378);
      --accent-weak: var(--grist-color-lighter-green, #B1FFE2);
      --selection: var(--grist-color-selection, rgba(22,179,120,.15));

      /* UI motion (cards only) */
      --fade-dur: 420ms;
      --fade-ease: cubic-bezier(.2,.8,.2,1);
      --fade-stagger: 60ms;
      --hover-dur: 180ms;

      /* static background colors */
      --bg-glow-a: rgba(22,179,120,.14);
      --bg-glow-b: rgba(22,179,120,.10);
      --grid-h: rgba(255,255,255,.028);
      --grid-v: rgba(255,255,255,.030);
      --grid-size: 72px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:var(--text);
      background: var(--bg);
      overflow-x:hidden;
      position:relative;
    }

    /* ===== Static background: soft green glows + thin grid (NO animations) ===== */
    /* layer 1: glows */
    body::after{
      content:"";
      position:fixed; inset:-15%;
      z-index:0; pointer-events:none;
      background:
        radial-gradient(1100px 720px at 110% -10%, var(--bg-glow-a), transparent 60%),
        radial-gradient(900px 600px at -8% 120%,  var(--bg-glow-b), transparent 60%);
      filter: blur(18px);
    }
    /* layer 2: grid (static) */
    body::before{
      content:"";
      position:fixed; inset:-10%;
      z-index:-1; pointer-events:none;
      background:
        repeating-linear-gradient(0deg,  var(--grid-h) 0 1px, transparent 1px var(--grid-size)),
        repeating-linear-gradient(90deg, var(--grid-v) 0 1px, transparent 1px var(--grid-size));
      background-size: var(--grid-size) var(--grid-size), var(--grid-size) var(--grid-size);
    }

    .wrapper{max-width:1100px; margin:0 auto; padding:28px 20px 40px; position:relative; z-index:1;}

    /* ---------- Header ---------- */
    .topbar{display:flex; align-items:center; justify-content:space-between; margin-bottom:18px}
    .title{font-size:22px; font-weight:700; letter-spacing:.2px}

    /* ---------- Grid & Cards ---------- */
    .grid{display:grid; grid-template-columns:repeat(12,1fr); gap:14px}

    .card{
      grid-column: span 12;
      position:relative; overflow:hidden;
      background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      border:1px solid #232a37; border-radius:18px; padding:18px;

      /* soft fade-in only */
      opacity:0;
      animation: fadeIn var(--fade-dur) var(--fade-ease) both;
      animation-delay: var(--delay, 0ms);

      transition: background var(--hover-dur) ease, border-color var(--hover-dur) ease;
    }
    @keyframes fadeIn { from{opacity:0} to{opacity:1} }

    .card:hover{
      background:linear-gradient(180deg, rgba(22,179,120,.06), rgba(61,217,163,.02));
      border-color:#2d3647;
    }

    .row{display:grid; grid-template-columns:1.6fr 1.4fr auto; align-items:center; gap:12px}
    .name{font-weight:600; font-size:16px}
    .role{color:var(--muted)}

    .badge{
      display:inline-flex; align-items:center; gap:8px;
      background:rgba(22,179,120,.14);
      color:#b9ffe7;
      border:1px solid rgba(22,179,120,.42);
      padding:8px 11px; border-radius:999px; font-weight:600; font-size:13px; text-decoration:none;
      transition: background var(--hover-dur) ease, border-color var(--hover-dur) ease;
      white-space:nowrap;
    }
    .badge:hover{
      background:rgba(22,179,120,.18);
      border-color:rgba(22,179,120,.52);
    }
    .badge:focus-visible{ outline:0; box-shadow:0 0 0 6px var(--selection); }
    .ext{ width:16px; height:16px; display:inline-block; }

    @media (min-width:700px){ .card{ grid-column: span 6 } }
    @media (min-width:980px){ .card{ grid-column: span 4 } }

    .empty{
      opacity:.9; color:var(--muted); text-align:center; padding:26px;
      border:1px dashed #2a3140; border-radius:14px; background:rgba(255,255,255,.015);
    }

    @media (prefers-reduced-motion: reduce){
      .card{ animation: none !important; opacity:1 !important }
      .badge, .card{ transition: none !important }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="topbar">
      <div class="title">Team directory</div>
    </div>

    <div id="grid" class="grid" aria-live="polite"></div>
  </div>

  <!-- Card template -->
  <template id="cardTpl">
    <div class="card">
      <div class="row">
        <div class="name"></div>
        <div class="role"></div>
        <a class="badge" target="_blank" rel="noopener noreferrer" href="#" aria-label="Open workspace">
          <svg class="ext" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M18 13v6a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
            <polyline points="15 3 21 3 21 9"/>
            <line x1="10" y1="14" x2="21" y2="3"/>
          </svg>
          Open workspace
        </a>
      </div>
    </div>
  </template>

  <script>
    // =======================
    //  CONFIG
    // =======================
    const CONFIG = {
      columns: { name: 'Staff', role: 'Role', link: 'Workspace' }, // ID колонок
      linkPolicy: { enforceEmbed: false, enforceStyle: 'singlePage' },   // только singlePage
      demoData: [],                                                      // локальные данные (вне Grist)
      source: { mode: 'fixed', tableId: 'p' }                            // фиксированная таблица
    };

    // =======================
    //  Utils
    // =======================
    const $ = (sel, root=document) => root.querySelector(sel);
    const normalizeId = (s) => (s||'').toString().replace(/^\$/,''); // убираем $ в начале ID

    // Безопасное извлечение URL из разных форматов ячейки
    function extractUrl(val){
      if (!val) return '';

      // HyperLink объект: {url, label/text}
      if (typeof val === 'object') {
        const u = val.url || val.href || val.link || '';
        return sanitizeUrl(u);
      }

      const s = String(val).trim();

      // Markdown: [label](url)
      const md = s.match(/\[[^\]]*\]\(([^)]+)\)/);
      if (md && md[1]) return sanitizeUrl(md[1]);

      // HTML: <a href="...">...</a>
      const ah = s.match(/href\s*=\s*["']([^"']+)["']/i);
      if (ah && ah[1]) return sanitizeUrl(ah[1]);

      // просто URL/домен
      return sanitizeUrl(s);
    }

    // Нормализация и защита URL, +style=singlePage для docs.getgrist.com
    function sanitizeUrl(raw){
      if (!raw) return '';
      let u = String(raw).trim();

      // https:/ -> https://
      u = u.replace(/^(https?):\/(?!\/)/i, (_,p) => `${p}://`);

      // если без схемы, но похож на домен — добавим https://
      if (!/^[a-z]+:\/\//i.test(u)) {
        if (/^docs\.getgrist\.com\b/i.test(u) || /^[a-z0-9.-]+\.[a-z]{2,}\b/i.test(u)) {
          u = 'https://' + u;
        }
      }

      // запрет опасных схем
      if (/^\s*javascript:/i.test(u) || /^\s*data:/i.test(u)) return '';

      // auto style=singlePage для docs.getgrist.com
      try {
        const url = new URL(u);
        if (/(^|\.)docs\.getgrist\.com$/i.test(url.hostname)) {
          const style = CONFIG.linkPolicy?.enforceStyle;

          // Если style задан и ещё не указан в ссылке — добавим
          if (style && !url.searchParams.has('style')) {
            url.searchParams.set('style', style);
          }

          // Если в итоге style=singlePage — embed не нужен
          const styleVal = (url.searchParams.get('style') || '').toLowerCase();
          if (styleVal === 'singlepage') {
            url.searchParams.delete('embed');
          } else if (CONFIG.linkPolicy?.enforceEmbed === true && !url.searchParams.has('embed')) {
            // Добавим embed только если явно задано и стиль не singlePage
            url.searchParams.set('embed','true');
          }

          u = url.toString();
        }
      } catch(e){
        // относительный путь — оставим как есть
      }

      return u;
    }

    // Сопоставление ID колонок (работает и с $Prefix)
    function resolveColumns(allKeys){
      const keys = allKeys.map(k => k.toString());
      const lc = keys.map(k => k.toLowerCase());
      const want = {
        name: normalizeId(CONFIG.columns.name),
        role: normalizeId(CONFIG.columns.role),
        link: normalizeId(CONFIG.columns.link)
      };

      const out = {name:null, role:null, link:null};
      for (const k of ['name','role','link']){
        if (!want[k]) continue;
        const i = lc.indexOf(want[k].toLowerCase());
        if (i>-1) out[k] = keys[i];
      }

      // fallback на подстрочный поиск
      const pick = (cur, variants) => {
        if (cur) return cur;
        for (const v of variants){
          let i = lc.indexOf(v.toLowerCase());
          if (i>-1) return keys[i];
          i = lc.findIndex(x => x.includes(v.toLowerCase()));
          if (i>-1) return keys[i];
        }
        return null;
      };

      return {
        name: pick(out.name, ['staff','name','employee']),
        role: pick(out.role, ['role','title','position']),
        link: pick(out.link, ['workspace_link','workspace','link','url'])
      };
    }

    // Нормализация строки
    function mapRow(row, cols){
      // row — объект "плоский": {ColA: val, ColB: val, ...}
      const src = row || {};
      return {
        name: src?.[cols.name] ?? '',
        role: src?.[cols.role] ?? '',
        link: extractUrl(src?.[cols.link])
      };
    }

    // Рендер (через fragment)
    function render(records){
      const grid = $('#grid');
      grid.innerHTML = '';

      if (!records || !records.length){
        grid.innerHTML = `
          <div class="empty">
            No data to display.
            <div style="margin-top:6px;font-size:12px">
              If you see this in Grist, check the widget access level (<b>Full document access</b> is required)
              and that visible columns include <b>Staff</b>, <b>Role</b>, <b>Workspace_link</b>.
            </div>
          </div>`;
        return;
      }

      const tpl = $('#cardTpl');
      const frag = document.createDocumentFragment();
      records.forEach((r, i) => {
        const card = tpl.content.firstElementChild.cloneNode(true);
        card.style.setProperty('--delay', `calc(${i} * var(--fade-stagger))`);
        $('.name', card).textContent = r.name || '—';
        $('.role', card).textContent = r.role || '';
        const a = $('a.badge', card);
        if (r.link) { a.href = r.link; } else { a.remove(); }
        frag.appendChild(card);
      });
      grid.appendChild(frag);
    }

    // Преобразование RowRecords из fetchTable(...) в массив объектов-строк
    function rowRecordsToArray(colData){
      if (!colData || typeof colData !== 'object') return [];
      const keys = Object.keys(colData).filter(k => k !== 'id');

      // определим длину по максимальному количеству значений среди колонок
      const len = Math.max(0, ...keys.map(k => Array.isArray(colData[k]) ? colData[k].length : 0));

      const rows = new Array(len).fill(null).map((_, i) => {
        const obj = {};
        for (const k of keys) {
          const arr = colData[k];
          obj[k] = Array.isArray(arr) ? arr[i] : undefined;
        }
        return obj;
      });
      return rows;
    }

    // =======================
    //  Init (fixed source)
    // =======================
    (function init(){
      // Вне Grist — просто рендерим demoData (если задано)
      if (!window.grist){
        render(CONFIG.demoData && CONFIG.demoData.length ? CONFIG.demoData : []);
        return;
      }

      // Читаем фиксированную таблицу: нужен доступ "full"
      grist.ready({ requiredAccess: 'full' });

      (async () => {
        try {
          const tableId = CONFIG.source?.tableId;
          if (!tableId) throw new Error('CONFIG.source.tableId is empty');

          // 1) Читаем колонко-ориентированные данные
          const rr = await grist.docApi.fetchTable(tableId);

          // 2) Превращаем в массив объектов-строк
          const rowsAsObjects = rowRecordsToArray(rr);

          // 3) Определяем соответствия колонок и рендерим
          const cols = resolveColumns(Object.keys(rowsAsObjects[0] || {}));
          const data = rowsAsObjects.map(r => mapRow(r, cols));
          render(data);
        } catch (err) {
          console.error('Fixed-source fetch error:', err);
          render([]);
        }
      })();
    })();
  </script>
</body>
</html>

